@page "/vote"
@{
    ViewData["Title"] = "GECどっちでSHOW";
}
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>@ViewData["Title"]</title>

    <!-- 外部CSS（wwwroot/css/vote.css） -->
    <link rel="stylesheet" href="~/css/vote.css" asp-append-version="true" />

    <script src="~/lib/signalr/signalr.min.js"></script>
</head>
<body>
    <header>
        <div class="title">GECどっちでSHOW</div>
        <div class="right">
            <span id="teamTag" class="tag hide"></span>
            <button id="editTeam" class="linkbtn">チーム名を設定</button>
        </div>
    </header>

    <main>
        <div class="card"><h2 id="q-title">読み込み中…</h2></div>

        <div id="voting-area">
            <div class="card">
                <div class="multiplier-section">
                    <div class="multiplier-title">点数を選択（全3問で各点数は1回ずつ使用可能）</div>
                    <div class="multipliers">
                        <button class="multiplier-btn" data-value="1"><div class="badge">1点</div><div>1点</div></button>
                        <button class="multiplier-btn" data-value="2"><div class="badge">2点</div><div>2点</div></button>
                        <button class="multiplier-btn" data-value="4"><div class="badge">4点</div><div>4点</div></button>
                    </div>
                </div>
            </div>
            <div class="card"><div class="choices" id="choices"></div></div>
        </div>

        <div id="voting-closed" class="card voting-closed hide">
            <div class="voting-closed-icon">⏸️</div>
            <div>回答受付停止中</div>
            <div style="font-size:14px;margin-top:8px;">ホストが回答開始ボタンを押すまでお待ちください</div>
        </div>

        <div id="msg">準備中...</div>
        <div class="status"><span id="dot" class="dot"></span><span id="stxt">接続準備中…</span></div>
    </main>

    <!-- チーム名入力モーダル -->
    <div id="backdrop" class="modal-backdrop">
        <div class="modal">
            <h3>チーム名を入力</h3>
            <p>発表や集計で使う表示名です。あとから変更できます。</p>
            <input id="teamInput" class="input" type="text" placeholder="例）チームA" maxlength="40" />
            <div class="row">
                <button id="cancelTeam" class="btn">あとで</button>
                <button id="saveTeam" class="btn btn-acc">決定</button>
            </div>
        </div>
    </div>

    <script>
        /* ===== 参照 ===== */
        const qTitle=document.getElementById('q-title');
        const wrap=document.getElementById('choices');
        const msg=document.getElementById('msg');
        const dot=document.getElementById('dot');
        const stxt=document.getElementById('stxt');
        const votingArea=document.getElementById('voting-area');
        const votingClosed=document.getElementById('voting-closed');
        const setConn=(ok,t)=>{dot.className='dot '+(ok?'ok':'ng');stxt.textContent=t||(ok?'オンライン':'オフライン');};

        /* ===== 状態 ===== */
        let selectedMultiplier=1;
        let usedMultipliers=[];
        let isVotingOpen=false;
        let hasVotedThisRound=false;
        let currentSelectedOption=null;
        let savedVotes={};
        let currentQuestionIndex=0;

        /* ===== SignalR 接続 & 安全Invoker ===== */
        const conn=new signalR.HubConnectionBuilder()
          .withUrl('/hub/vote',{transport:signalR.HttpTransportType.WebSockets})
          .withAutomaticReconnect()
          .build();

        let isConnReady=false;
        const invokeQueue=[];
        function safeInvoke(method, ...args){
          if(isConnReady){
            return conn.invoke(method, ...args).catch(()=>{});
          }else{
            invokeQueue.push([method,args]);
            return Promise.resolve();
          }
        }
        function flushInvokeQueue(){
          while(invokeQueue.length){
            const [m,a]=invokeQueue.shift();
            conn.invoke(m, ...a).catch(()=>{});
          }
        }

        /* ===== チーム名 ===== */
        const KEY='gec_team_name';
        const teamTag=document.getElementById('teamTag');
        const editTeam=document.getElementById('editTeam');
        const backdrop=document.getElementById('backdrop');
        const teamInput=document.getElementById('teamInput');
        const cancelTeam=document.getElementById('cancelTeam');
        const saveTeam=document.getElementById('saveTeam');

        function getTeam(){ return (localStorage.getItem(KEY)||'').trim(); }
        function setTeam(v){
          const name=(v||'').trim();
          if(name){ localStorage.setItem(KEY,name); teamTag.textContent='👥 '+name; teamTag.classList.remove('hide'); }
          else{ localStorage.removeItem(KEY); teamTag.textContent=''; teamTag.classList.add('hide'); }
          safeInvoke('UpdateTeamName', name);
          updateVoteButtons();
        }
        function updateVoteButtons(){
          const teamNow=getTeam();
          const canVote=teamNow && isVotingOpen && selectedMultiplier>0 && !hasVotedThisRound;
          for(const b of document.querySelectorAll('.choice')) b.disabled=!canVote;
        }
        function openModal(prefill){ teamInput.value=prefill||getTeam(); backdrop.style.display='flex'; setTimeout(()=>teamInput.focus(),0); }
        function closeModal(){ backdrop.style.display='none'; }
        editTeam.onclick=()=>openModal();
        cancelTeam.onclick=()=>closeModal();
        saveTeam.onclick=()=>{
          const v=teamInput.value;
          if(!v || !v.trim()){ teamInput.focus(); return; }
          setTeam(v); closeModal(); msg.textContent='チーム名を設定しました';
        };

        /* ==== 既回答のローカル保存をUIに反映（リロード対策） ==== */
        function applySavedVoteUI(){
          const saved = savedVotes[currentQuestionIndex];
          if(!isVotingOpen || !saved) return;

          hasVotedThisRound = true;
          currentSelectedOption = saved.option || null;
          selectedMultiplier = saved.multiplier || 0;

          // 選択肢ボタン固定＆ハイライト
          document.querySelectorAll('.choice').forEach(b=>{
            b.disabled = true;
            const txt = b.textContent||'';
            if(currentSelectedOption && txt.startsWith(currentSelectedOption+' ')){
              b.classList.add('selected-answer');
            }
          });

          // 倍率ボタン：使った倍率だけ選択固定、他は触れない
          document.querySelectorAll('.multiplier-btn').forEach(btn=>{
            const v = parseInt(btn.dataset.value);
            btn.classList.remove('selected');
            if(v === selectedMultiplier){
              btn.disabled = true;
              btn.classList.add('used','selected');
              btn.style.pointerEvents = 'none';
              btn.style.opacity = '0.7';
            }else{
              btn.style.pointerEvents = 'none';
              btn.style.opacity = '0.7';
              if(usedMultipliers.includes(v)){
                btn.disabled = true;
                btn.classList.add('used');
              }
            }
          });

          msg.textContent = `この問題は ${currentSelectedOption} (${selectedMultiplier||'?'}点) で回答済みです`;
        }

        /* ===== SignalR: StateUpdated ===== */
        conn.on('StateUpdated', s=>{
          const q=s.question||{}; const opts=q.options||[];
          isVotingOpen=s.isVotingOpen||false;
          const newIndex=s.currentIndex||0;

          // 問題切替時に表示リセット
          if(newIndex!==currentQuestionIndex){
            currentQuestionIndex=newIndex;
            hasVotedThisRound=false; currentSelectedOption=null;
            document.querySelectorAll('.choice').forEach(b=>b.classList.remove('selected-answer'));
          }

          // サーバの自チーム回答が無ければ、ローカル保存を解放（=ホストが削除したケース）
          const myTeam=(getTeam()||'').trim();
          const serverHasMyVote = !!(s.clientVotes && myTeam && s.clientVotes[myTeam]);
          const localSaved = savedVotes[currentQuestionIndex];
          if(!serverHasMyVote && localSaved){
            const freed = Number(localSaved.multiplier||0);
            delete savedVotes[currentQuestionIndex];
            localStorage.setItem('gec_saved_votes', JSON.stringify(savedVotes));
            if(freed && usedMultipliers.includes(freed)){
              usedMultipliers = usedMultipliers.filter(x=>x!==freed);
              localStorage.setItem('gec_used_multipliers', JSON.stringify(usedMultipliers));
            }
            hasVotedThisRound=false;
            currentSelectedOption=null;
            selectedMultiplier=0;
          }

          qTitle.textContent=q.title||'';

          if(isVotingOpen){
            votingArea.classList.remove('hide'); votingClosed.classList.add('hide');
            msg.textContent = hasVotedThisRound ? `この問題は ${currentSelectedOption} (${savedVotes[currentQuestionIndex]?.multiplier||'?'}点) で回答済みです` : '点数を選択してから回答してください';
          }else{
            votingArea.classList.add('hide'); votingClosed.classList.remove('hide'); msg.textContent='回答受付停止中';
          }

          // 選択肢再描画
          wrap.innerHTML='';
          const teamNow=getTeam();
          for(const o of opts){
            const label=o.label??o.Label??'-';
            const b=document.createElement('button');
            b.className='choice'; b.textContent=`${label} を選ぶ`;
            b.disabled=!teamNow || !isVotingOpen || selectedMultiplier===0 || hasVotedThisRound;
            if(currentSelectedOption===label) b.classList.add('selected-answer');
            b.onclick=()=>{
              if(!selectedMultiplier){ msg.textContent='先に点数を選択してください'; return; }
              if(hasVotedThisRound){ msg.textContent='この問題は既に回答済みです'; return; }
              showConfirmModal(label, teamNow);
            };
            wrap.appendChild(b);
          }
          setConn(true);
          updateVoteButtons();

          // リロード直後の復元
          applySavedVoteUI();
        });

        /* 開始/終了 */
        conn.on('VotingStatusChanged', isOpen=>{
          isVotingOpen=isOpen;
          if(isOpen){
            hasVotedThisRound=false; currentSelectedOption=null;
            document.querySelectorAll('.multiplier-btn').forEach(btn=>{
              const v=parseInt(btn.dataset.value);
              btn.classList.remove('selected');
              if(usedMultipliers.includes(v)){ btn.disabled=true; btn.classList.add('used'); btn.style.pointerEvents=''; btn.style.opacity=''; }
              else{ btn.disabled=false; btn.classList.remove('used'); btn.style.pointerEvents=''; btn.style.opacity=''; }
            });
            selectedMultiplier=0;
            votingArea.classList.remove('hide'); votingClosed.classList.add('hide');
            msg.textContent='点数を選択してから回答してください';
            applySavedVoteUI();
          }else{
            votingArea.classList.add('hide'); votingClosed.classList.remove('hide'); msg.textContent='回答受付停止中';
          }
          updateVoteButtons();
        });

        /* 回答確定：自動シフトさせない */
        conn.on('MultiplierUsed', multiplier=>{
          if(!usedMultipliers.includes(multiplier)) usedMultipliers.push(multiplier);
          hasVotedThisRound=true;
          selectedMultiplier = multiplier;
          document.querySelectorAll('.multiplier-btn').forEach(btn=>{
            const v=parseInt(btn.dataset.value);
            if(v===multiplier){ btn.disabled=true; btn.classList.add('used','selected'); }
            else{
              btn.style.pointerEvents='none'; btn.style.opacity='0.7';
              if(usedMultipliers.includes(v)){ btn.disabled=true; btn.classList.add('used'); }
            }
          });
          if(currentSelectedOption){
            if(!savedVotes[currentQuestionIndex]) savedVotes[currentQuestionIndex]={};
            savedVotes[currentQuestionIndex]={ option: currentSelectedOption, multiplier };
            localStorage.setItem('gec_saved_votes', JSON.stringify(savedVotes));
          }
          localStorage.setItem('gec_used_multipliers', JSON.stringify(usedMultipliers));
          updateVoteButtons();
        });

        /* 回答一覧（ホストと同じ） */
        conn.on('ShowPerQuestionResults',(index,rows)=>{
          const myTeam=(getTeam()||'').trim();
          const groups={A:[],B:[]};
          (rows||[]).forEach(r=>{
            const opt=String(r.selectedOption||r.SelectedOption||'-').toUpperCase();
            const team=String(r.teamName||r.TeamName||'').trim();
            const mul=Number(r.multiplier||r.Multiplier||1);
            const rt=Number(r.responseTime||r.ResponseTime||0);
            if(!team) return;
            if(opt==='A'||opt==='B') groups[opt].push({team,mul,rt});
          });
          const countA=groups.A.length, countB=groups.B.length;

          const modal=document.createElement('div');
          modal.className='confirm-modal'; modal.style.display='flex'; modal.style.zIndex='2000';

          let html='';
          ['A','B'].forEach(opt=>{
            const list=groups[opt];
            html+=`
              <div style="margin-bottom:20px;padding:16px;background:#f9fafb;border-radius:8px;">
                <div style="font-size:18px;font-weight:700;color:#111;margin-bottom:12px;">
                  選択肢 ${opt} <span style="font-weight:400;color:#666;">(${list.length}チーム)</span>
                </div>
                <div style="display:flex;flex-wrap:wrap;gap:8px;">
                  ${list.map(x=>{
                    const mine=x.team===myTeam;
                    return `<div style="padding:8px 12px;background:${mine?'#fef3c7':'#fff'};border:1px solid ${mine?'#f59e0b':'#e5e7eb'};border-radius:6px;">
                              <span style="font-weight:600;">${x.team}</span>
                              <span style="color:#666;margin-left:8px;">×${x.mul}</span>
                              ${mine?'<span style="color:#f59e0b;margin-left:8px;">(あなた)</span>':''}
                            </div>`;
                  }).join('') || `<div style="color:#666;font-style:italic;">回答なし</div>`}
                </div>
              </div>`;
          });

          modal.innerHTML=`
            <div class="confirm-box">
              <div class="confirm-title">回答一覧（A: ${countA}チーム / B: ${countB}チーム）</div>
              <div style="margin:20px 0; max-height:60vh; overflow:auto;">${html}</div>
              <div class="confirm-buttons">
                <button class="confirm-btn confirm-ok" style="width:100%;font-size:18px;padding:18px;">閉じる</button>
              </div>
            </div>`;
          document.body.appendChild(modal);
          modal.querySelector('.confirm-ok').onclick=()=> document.body.removeChild(modal);
        });
        conn.on('ClosePerQuestionResults',()=>{ const m=document.querySelector('.confirm-modal'); if(m) m.remove(); });

        /* 最終結果 */
        conn.on('GameResults', results=>{
          const modal=document.createElement('div');
          modal.className='confirm-modal'; modal.style.display='flex'; modal.style.zIndex='2000';
          let html='<table style="width:100%;border-collapse:collapse;"><tr><th style="text-align:left;padding:8px;border-bottom:1px solid #e5e7eb;">順位</th><th style="text-align:left;padding:8px;border-bottom:1px solid #e5e7eb;">チーム名</th><th style="text-align:left;padding:8px;border-bottom:1px solid #e5e7eb;">合計点数</th><th style="text-align:left;padding:8px;border-bottom:1px solid #e5e7eb;">合計時間(秒)</th></tr>';
          (results||[]).forEach((r,i)=>{
            const rank=i+1, badge=rank===1?' 🏆':(rank===2?' 🥈':(rank===3?' 🥉':''));
            const teamName=(r.teamName||r.TeamName||'').trim();
            const t=(r.totalTime||r.TotalTime||0).toFixed(1);
            html+=`<tr><td style="padding:8px;border-bottom:1px solid #e5e7eb;">${rank}${badge}</td><td style="padding:8px;border-bottom:1px solid #e5e7eb;">${teamName||'（未設定）'}</td><td style="padding:8px;border-bottom:1px solid #e5e7eb;">${r.totalPoints||r.TotalPoints||0}点</td><td style="padding:8px;border-bottom:1px solid #e5e7eb;">${t}</td></tr>`;
          });
          html+='</table>';
          modal.innerHTML=`
            <div class="confirm-box" style="max-width:600px;">
              <div class="confirm-title">最終結果</div>
              <div style="margin:20px 0;overflow-x:auto;">${html}</div>
              <div class="confirm-buttons"><button class="confirm-btn confirm-ok" style="width:100%;font-size:18px;padding:18px;">閉じる</button></div>
            </div>`;
          document.body.appendChild(modal);
          modal.querySelector('.confirm-ok').onclick=()=> document.body.removeChild(modal);
        });

        /* ★ 回答削除：未使用の倍率は再選択可に戻す＆自動選択なし（オンライン時） */
        conn.on('VoteDeleted',(clientId,deletedMultiplier)=>{
          const myId=conn.connectionId;
          if(!myId || clientId!==myId) return;

          if(deletedMultiplier && usedMultipliers.includes(deletedMultiplier)){
            usedMultipliers = usedMultipliers.filter(x=>x!==deletedMultiplier);
            localStorage.setItem('gec_used_multipliers', JSON.stringify(usedMultipliers));
          }

          // この設問のローカル回答も解除
          if(savedVotes[currentQuestionIndex]){
            delete savedVotes[currentQuestionIndex];
            localStorage.setItem('gec_saved_votes', JSON.stringify(savedVotes));
          }

          hasVotedThisRound=false;
          currentSelectedOption=null;
          selectedMultiplier=0;
          document.querySelectorAll('.choice').forEach(b=>b.classList.remove('selected-answer'));

          document.querySelectorAll('.multiplier-btn').forEach(btn=>{
            const v=parseInt(btn.dataset.value);
            btn.classList.remove('selected');
            btn.style.pointerEvents='';
            btn.style.opacity='';
            if(usedMultipliers.includes(v)){ btn.disabled=true; btn.classList.add('used'); }
            else{ btn.disabled=false; btn.classList.remove('used'); }
          });

          msg.textContent='回答が削除されました。倍率を選び直して回答できます';
          updateVoteButtons();
        });

        /* 接続 */
        conn.start()
          .then(()=>{
            isConnReady=true;
            setConn(true,'オンライン');
            flushInvokeQueue();
            const n=getTeam();
            if(n) safeInvoke('UpdateTeamName', n);
            return safeInvoke('GetState');
          })
          .catch(()=> setConn(false,'接続できません'));

        conn.onreconnecting(()=>{ isConnReady=false; setConn(false,'再接続中…'); });
        conn.onreconnected(()=>{
          isConnReady=true;
          setConn(true,'オンライン');
          flushInvokeQueue();
          const n=getTeam();
          if(n) safeInvoke('UpdateTeamName', n);
          safeInvoke('GetState');
        });
        conn.onclose(()=> setConn(false,'切断されました'));
        addEventListener('offline', ()=> setConn(false,'オフライン'));
        addEventListener('online',  ()=> setConn(true,'オンライン'));

        /* 起動時：ローカル復元（使用済み倍率の見た目だけ先に反映） */
        window.addEventListener('load',()=>{
          const name=getTeam(); setTeam(name); if(!name){ openModal(''); }
          const savedData=localStorage.getItem('gec_saved_votes');
          const savedM=localStorage.getItem('gec_used_multipliers');
          if(savedData){ try{ savedVotes=JSON.parse(savedData);}catch{ localStorage.removeItem('gec_saved_votes'); } }
          if(savedM){ try{
            usedMultipliers=JSON.parse(savedM);
            usedMultipliers.forEach(m=>{ const btn=document.querySelector(`.multiplier-btn[data-value="${m}"]`); if(btn){ btn.disabled=true; btn.classList.add('used'); }});
          }catch{ localStorage.removeItem('gec_used_multipliers'); } }
          document.querySelectorAll('.multiplier-btn').forEach(btn=>{
            btn.addEventListener('click',()=>{
              if(btn.disabled||btn.classList.contains('used')) return;
              if(hasVotedThisRound){ msg.textContent='回答後は倍率を変更できません'; return; }
              document.querySelectorAll('.multiplier-btn').forEach(b=>b.classList.remove('selected'));
              btn.classList.add('selected'); selectedMultiplier=parseInt(btn.dataset.value);
              updateVoteButtons(); msg.textContent=`${selectedMultiplier}点を選択しました`;
            });
          });
          document.querySelector('.multiplier-btn[data-value="1"]').classList.add('selected');
        });

        /* リセット（ホスト操作反映） */
        conn.on('GameReset', ()=>{
          usedMultipliers=[]; selectedMultiplier=1; hasVotedThisRound=false; currentSelectedOption=null; savedVotes={}; currentQuestionIndex=0;
          localStorage.removeItem('gec_saved_votes'); localStorage.removeItem('gec_used_multipliers');
          document.querySelectorAll('.multiplier-btn').forEach(btn=>{ btn.disabled=false; btn.classList.remove('used','selected'); });
          document.querySelector('.multiplier-btn[data-value="1"]').classList.add('selected');
          document.querySelectorAll('.choice').forEach(b=>b.classList.remove('selected-answer'));
          msg.textContent='ゲームがリセットされました';
        });

        /* 送信確認（送信時の倍率を固定表示） */
        function showConfirmModal(label,teamName){
          const modal=document.createElement('div');
          modal.className='confirm-modal'; modal.style.display='flex';
          modal.innerHTML=`
            <div class="confirm-box">
              <div class="confirm-title">📝 回答確認</div>
              <div class="confirm-message">この選択で回答します。<br>一度回答すると変更できません。</div>
              <div class="confirm-choice">${label}</div>
              <div class="confirm-choice-detail">
                <div class="confirm-choice-item"><div class="confirm-choice-label">チーム名</div><div class="confirm-choice-value">${teamName||'未設定'}</div></div>
                <div class="confirm-choice-item"><div class="confirm-choice-label">使用ポイント</div><div class="confirm-choice-value">${selectedMultiplier||'-'}点</div></div>
              </div>
              <div class="confirm-buttons">
                <button class="confirm-btn confirm-cancel">戻る</button>
                <button class="confirm-btn confirm-ok">確定する ✓</button>
              </div>
            </div>`;
          document.body.appendChild(modal);

          modal.querySelector('.confirm-cancel').onclick=()=> document.body.removeChild(modal);
          modal.querySelector('.confirm-ok').onclick=()=>{
            const chosenMultiplier = selectedMultiplier;
            if(!chosenMultiplier){ msg.textContent='先に点数を選択してください'; return; }
            currentSelectedOption=label;
            // 接続準備ができていない場合でも安全にキューして送信
            safeInvoke('SubmitWithMultiplier', label, chosenMultiplier, teamName);
            msg.textContent=`${teamName?('['+teamName+'] '):''}${label} を ${chosenMultiplier}点で選択しました`;
            try{ navigator.vibrate && navigator.vibrate(15);}catch{}
            document.body.removeChild(modal);
          };
        }
    </script>
</body>
</html>
